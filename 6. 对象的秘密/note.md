# 学习笔记

## 6.1 封装

* 面向对象的核心思想是将程序划分为更小的部分，并使每个部分负责管理自己的状态。这样的程序的不同部分通过接口、有限的函数集或绑定彼此交互
* 程序块使用对象建模，它们的接口由一组特定的方法和属性组成。属于该接口的属性称为公共的，外部代码不应该触及的其他内容称为私有的
* 在属性名称的开头加上下划线以表示这些属性是私有的
* 将接口与实现分离是一个好主意，它通常称为封装

## 6.2 方法

* 方法只不过是保存函数值的属性
* 通常，方法需要对调用它的对象执行某些操作。当一个函数作为一个方法被调用（作为一个属性查询被立即调用）时，在它的函数体中的this绑定会自动指向调用它的对象
* 可以将this视为不同方式传递的额外参数。如果要显示传递它，可以使用函数的call方法，此方法将第一次参数作为this的值，将其他参数视为普通参数
* 每个函数都有自己的this绑定，其值取决于它的调用方式。
* 不能在使用function关键字定义的常规函数中引用包装作用域中的this。箭头函数不同，不绑定自己的this，可以看到围绕它的作用域的this绑定

## 6.3 原型

* 除了自己的属性集之外，大多数对象还都有一个原型
* 原型是另一个用作属性后备源的对象。当一个对象收到一个对它没有的属性的请求时，将到它的原型那里搜索这个属性，然后是原型的原型，以此类推
* Object.getPrototypeOf返回一个对象的原型
* 许多对象不直接将Object.prototype作为原型，而是使用另一个提供不同默认属性集的对象，例如：函数派生自Function.prototype，数组派生自Array.prototype
* 可以使用Object.create创建具有特定原型的对象

## 6.4 类

* JavaScript的原型系统可以解释为面向对象编程中类（class）的概念的一种非正式的实现
* 原型可用于定义类的所有实例共享相同值
* 要创建给定类的实例，必须创建一个派生自适当原型的对象，还必须确保实例具有此类实例应具有的属性。通过传统构造函数事项
* JavaScript提供了一种定义构造函数更方便的方法。如果将关键字new放在函数调用的前面，则此函数将被视为构造函数。这意味着具有正确原型的对象会自动创建，在函数中绑定到this，并在函数末尾返回
* 构造函数的prototype（指针）指向原型，实例的\__proto__检查(Object.getPrototypeOf检查)指向其原型
* 因为构造函数是函数，所以它的实际原型是Function.prototype。它的prototype属性保存的是通过它创建的实例的原型

## 6.5 类表示法

* JavaScript类就是带有prototype属性的构造函数
* 新的声明类的方式：class关键字，它允许在同一个地方同时定义一个构造函数和一组方法。可以在声明的大括号内写入任意数量的方法，名为constructor的方法被特殊处理（它提供了实际的构造函数）
* 与function类似，class可以在语句和表达式中使用。当用作表达式时，它不定义绑定，而只是将构造函数作为值生成。你可以在类表达式中省略类名

## 6.6 覆盖派生属性

* 向对象添加属性时，无论它是否存在于原型中，属性都会被添加到对象本身，原型中的同名属性不再影响这个对象
* 覆盖也可用于为标准函数和数组原型提供与基本对象原型（Object.prototype）不同的toString方法

## 6.7 映射

* map（映射）是将“键”和“其他值”相关联的数据结构，可以使用对象实现这种需求
* 因为普通对象派生自Object.prototype，所以使用普通对象作为映射是危险的，有几种方法可以避免这个问题：
  * 可以创建没有原型的对象：将null传递给Object.create，则生成的对象不会从Object.prototype派生
  * 使用Map类，Map的对象接口有set、get、has方法
  * 如果因为某种原因确实有普通对象需要被视为一个映射:
    * Object.keys只返回对象自己的键，以数组形式返回，如果需要遍历应使用for...of
    * 如果直接使用for...in遍历对象的key，会将原型中的属性也遍历出来
    * 作为in运算符的替代，使用hasOwnProperty方法可以忽略对象的原型

## 6.8 多态性

* 多态代码可以使用不同类型的值，只要它们支持所期望的接口即可

## 6.9 符号

* 多个接口可以使用相同的属性名称来进行不同的操作
* 属性名称通常是字符串，但它们也可以是符号。符号是使用Symbol函数创建的值，新创建的符号是唯一的
* 可以把Symbol函数当成一个类似UUID的东西，永不重复。符号的字符串名称相当于注释
* 符号既独一无二又可用作属性名，使得它适用于定义可以与其他属性（无论属性的名称是什么）并行生存的接口
* 在属性名称周围使用方括号，可以在对象表达式和类表达式中包含符号属性。这会导致对属性名称进行求值，就好像方括号属性访问表示法一样，使得我们能够引用包含符号的绑定

## 6.10 迭代器接口

* 赋予for...of循环的对象应该是可迭代的，这意味着它有一个用Symbol.iterator符号（语言定义的符号值，存储为Symbol函数的属性）命名的方法
* Symbol.iterator返回一个提供第二接口的对象——迭代器，它有一个next方法来返回下一个结果。这个结果是对象，包含下一个value属性和done属性，当没有更多结果时，done为true
* next、value、done属性名称是纯字符串而不是符号

## 6.11 读取器、设置器和静态

* getter（读取器），是通过在对象表达式或类声明中将get写入方法名之前来定义的
* setter（设置器），是通过在对象表达式或类声明中将set写入方法名之前来定义的
* 在类声明中，在名称之前写入static（静态）的方法被存储在构造函数中

## 6.12 继承

## 6.13 instanceof运算符
