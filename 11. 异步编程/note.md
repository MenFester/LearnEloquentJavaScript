# 学习笔记

## 11.1 异步

* 操作系统在多个正在运行的程序之间切换处理器。但是，如果我们希望单个程序在等待网络请求时能够取得进展，这种切换无济于事
* 同步编程模型中，在同一时间只能发生一件事情
  * 当调用要执行某个长时间运行的操作的函数，它仅在操作完成后返回，并且只有在那时才可以返回结果
  * 在同步系统中，克服缺点的方法是启动额外的控制线程（线程是另一个正在运行的程序，它可以在操作系统的管理下与其他程序交错执行），多线程甚至可以在不同的处理器上同时运行
* 异步模型允许同时发生多件事情
  * 开始某项操作时，程序将继续运行。操作完成后程序将收到通知并允许访问结果
  * 异步模型从概念上说会导致时间轴的拆分，启动操作的程序继续进行，而它启动的操作与其并行执行，并在自己完成时通知此程序
* 同步模型中等待操作结束是隐式的，而在异步模型中，在我们的控制下它是显式的
* 异步性是双刃剑：一方面它使得表达不适合线性控制模型的程序更容易，但另一方面它也使得表达遵守线性控制模型的程序更加不便
* 两个重要的JavaScript编程平台：浏览器和Node.js，都允许可能需要一段时间的操作异步进行，而不依赖于线程。（用线程编程是很困难的，理解一个程序在做多个事情的时候所做的事情要困难得多）

## 11.2 乌鸦技术

## 11.3 回调

* 异步编程的一种方法是使执行慢速操作的函数采用额外的参数——回调函数（操作完成后将使用结果调用回调函数）
* 使用回调函数来连续执行多个异步操作意味着你必须持续传递新函数以处理后续计算
* 某种程度上，异步性具有传染性。调用异步工作的函数的任何函数本身必须是异步的，使用回调或类似机制来传递结果
* 调用回调函数比简单地返回一个值涉及更多的东西并且容易出错，因此需要以这种方法构建程序的大部分内容并不太好

## 11.4 promise

* 当抽象概念可以用值来表示时，这些概念通常更容易使用。在异步操作的情况下，你可以不用安排在未来某个时间调用回调函数，而返回表示此未来事件的对象，这就是promise标准类的用途
* promise是一种异步行为，它可以在某个时刻完成并产生值。它能够在有值时通知任何感兴趣的人
* 创建promise的最简单方法是调用Promise.resolve，此函数确保你提供的值包含在promise中
  * 如果它已经是个promise，它就会被简单返回
  * 否则会得到一个新的promise，它以你的值为结果立即结束
* 获得promise的结果，可以使用then方法，这会在promise解决并生成值时调用一个回调函数
* 可以向单个promise添加多个回调函数，并且即使你在promise已经解决（已完成）之后才添加回调函数，也会调用它们
* then返回另一个promise，其解决处理函数返回的值，如果返回一个promise，则等待该promise然后解决其结果
* 要创建一个promise，可以使用Promise作为构造函数（需要一个函数作为参数，它会立即调用作为参数的函数，想作为参数的函数传递一个可以用来解决promise的函数，resolve）
  * resolve作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去
  * reject作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去
* promise有三个状态：
  * pending[待定]初始状态
  * fulfilled[实现]操作成功
  * rejected[被否决]操作失败
* 当promise状态发生改变，就会触发then()里的响应函数处理后续步骤。promise状态一经改变，不会再变。Promise对象的状态改变，只有两种可能
  * 从pending变为fulfilled
  * 从pending变为rejected
  * 这两种情况只要发生，状态就凝固了，不会再变了
* 基于promise的函数看起来与常规函数类似，而不必传递回调：它们将输入作为参数并返回其输出。此函数与常规函数唯一的区别是，输出可能还没有得到

## 11.5 失败

## 11.6 构建网络很困难

## 11.7 promise集合

## 11.8 网络泛洪

## 11.9 消息路由

## 11.10 异步函数

## 11.11 生成器

## 11.12 事件循环

## 11.13 异步bug
