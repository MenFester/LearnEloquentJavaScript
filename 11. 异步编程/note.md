# 学习笔记

## 11.1 异步

* 操作系统在多个正在运行的程序之间切换处理器。但是，如果我们希望单个程序在等待网络请求时能够取得进展，这种切换无济于事
* 同步编程模型中，在同一时间只能发生一件事情
  * 当调用要执行某个长时间运行的操作的函数，它仅在操作完成后返回，并且只有在那时才可以返回结果
  * 在同步系统中，克服缺点的方法是启动额外的控制线程（线程是另一个正在运行的程序，它可以在操作系统的管理下与其他程序交错执行），多线程甚至可以在不同的处理器上同时运行
* 异步模型允许同时发生多件事情
  * 开始某项操作时，程序将继续运行。操作完成后程序将收到通知并允许访问结果
  * 异步模型从概念上说会导致时间轴的拆分，启动操作的程序继续进行，而它启动的操作与其并行执行，并在自己完成时通知此程序
* 同步模型中等待操作结束是隐式的，而在异步模型中，在我们的控制下它是显式的
* 异步性是双刃剑：一方面它使得表达不适合线性控制模型的程序更容易，但另一方面它也使得表达遵守线性控制模型的程序更加不便
* 两个重要的JavaScript编程平台：浏览器和Node.js，都允许可能需要一段时间的操作异步进行，而不依赖于线程。（用线程编程是很困难的，理解一个程序在做多个事情的时候所做的事情要困难得多）

## 11.2 乌鸦技术

## 11.3 回调

* 异步编程的一种方法是使执行慢速操作的函数采用额外的参数——回调函数（操作完成后将使用结果调用回调函数）
* 使用回调函数来连续执行多个异步操作意味着你必须持续传递新函数以处理后续计算
* 某种程度上，异步性具有传染性。调用异步工作的函数的任何函数本身必须是异步的，使用回调或类似机制来传递结果
* 调用回调函数比简单地返回一个值涉及更多的东西并且容易出错，因此需要以这种方法构建程序的大部分内容并不太好

## 11.4 promise

* 当抽象概念可以用值来表示时，这些概念通常更容易使用。在异步操作的情况下，你可以不用安排在未来某个时间调用回调函数，而返回表示此未来事件的对象，这就是promise标准类的用途
* promise是一种异步行为，它可以在某个时刻完成并产生值。它能够在有值时通知任何感兴趣的人
* 创建promise的最简单方法是调用Promise.resolve，此函数确保你提供的值包含在promise中
  * 如果它已经是个promise，它就会被简单返回
  * 否则会得到一个新的promise，它以你的值为结果立即结束
* 获得promise的结果，可以使用then方法，这会在promise解决并生成值时调用一个回调函数
* 可以向单个promise添加多个回调函数，并且即使你在promise已经解决（已完成）之后才添加回调函数，也会调用它们
* then返回另一个promise，其解决处理函数返回的值，如果返回一个promise，则等待该promise然后解决其结果
* 要创建一个promise，可以使用Promise作为构造函数（需要一个函数作为参数，它会立即调用作为参数的函数，想作为参数的函数传递一个可以用来解决promise的函数，resolve）
  * resolve作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去
  * reject作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去
* promise有三个状态：
  * pending[待定]初始状态
  * fulfilled[实现]操作成功
  * rejected[被否决]操作失败
* 当promise状态发生改变，就会触发then()里的响应函数处理后续步骤。promise状态一经改变，不会再变。Promise对象的状态改变，只有两种可能
  * 从pending变为fulfilled
  * 从pending变为rejected
  * 这两种情况只要发生，状态就凝固了，不会再变了
* 基于promise的函数看起来与常规函数类似，而不必传递回调：它们将输入作为参数并返回其输出。此函数与常规函数唯一的区别是，输出可能还没有得到

## 11.5 失败

* 常规JavaScript计算失败可以通过抛出异常来处理
* 异步编程的回调风格最紧迫的问题之一是，它很难确保失败被正确地报告给回调函数。一种广泛的约定是，回调函数的第一个参数用于指示操作失败，第二个参数包含操作成功时生成的值。这样的回调函数必须始终检查它们是否收到异常，并确保它们引起的任何问题（包括调用的函数抛出异常）都被捕获并提供给正确的函数
* promise既可以被解决（动作成功完成），也可以被拒绝（动作失败）。只有在操作成功时才会调用解决处理程序（当用then注册时），并且拒绝会自动传播到由then返回的新promise。当处理程序抛出异常时，会自动导致其then调用产生的promise被拒绝
* 就像解决promise会提供一个值一样，拒绝一个promise也会提供一个值，这个值通常被称为拒绝的原因
* 为了显示处理拒绝，promise有一个catch方法，它在promise被拒绝时注册要调用的处理程序。如果catch处理程序抛出错误，则新的promise也会被拒绝
* 作为简写，then还接受拒绝处理程序作为第二个参数。  
* 传递给Promise构造函数的函数接收第二个参数（reject）可以用来拒绝新的promise
* 通过调用then和catch创建的promise值链，可以看作异步值或失败值移动的管道。由于这些链式通过注册处理程序创建的，因此每个链都有一个与之关联的成功处理程序或拒绝处理程序（或两者都有）。与结果类型（成功或失败）不匹配的处理程序将被忽略。只有那些匹配的处理程序才会被调用，并且它们的结果决定了随后得出的值的种类（当它返回非promise值时成功，当它抛出异常时拒绝）和结果，而结果就是promise返回上述两种情况中的一种
* 当promise的拒绝未被处理时，JavaScript环境也可以检测到这种情况并将其报告为错误

## 11.6 构建网络很困难

## 11.7 promise集合

## 11.8 网络泛洪

## 11.9 消息路由

## 11.10 异步函数

## 11.11 生成器

## 11.12 事件循环

## 11.13 异步bug
