# 学习笔记

## 8.1 语言

* JavaScript的模糊性是一种障碍，它的绑定和属性的概念太过模糊，通常无意义计算只会产生NaN（不是数字）或undefined（未定义的值）
* 查找程序中错误（bug）的过程称为调试（debug）

## 8.2 严格模式

* 通过启用严格模式（将字符串“use strict”放在文件或函数体的开头），可以使JavaScript变得略微严格
* 严格模式的另一个变化是this绑定在未作为构造函数调用（没有使用new关键字）的函数中保存未定义的值。在严格模式之外进行此类调用时，this指的是全局范围作用域，此对象的属性是全局绑定。幸运的是，使用class创建的构造函数，如果不被带new关键字地调用，始终报错（即使在非严格模式下）
* 严格模式不允许给一个函数赋予相同名称的多个参数
* 在程序的开头放置“use strict”很少会伤害程序并可能帮助你发现问题

## 8.3 类型

* JavaScript只有在实际运行程序时才考虑类型，甚至经常尝试将值隐式地转换为它期望的类型。许多错误都归咎于进入函数或函数返回的值的类型的混淆

## 8.4 测试

* 自动化测试就是编写程序来测试另一个程序
* 测试通常采用小标签程序的形式来验证代码的某些方面
* 有些软件（测试套件）通过提供适合表达测试的语言并在测试失败时输出丰富的信息，可以帮助你构建和运行测试集合
* 通常，代码与之交互的外部对象越多，设置上下文来测试它就约困难

## 8.5 调试

* 将一些策略性的console.log调用放入程序中是获取有关程序正在执行的操作的信息的好方法
* 使用console.log查看程序行为的另一种方法是使用浏览器的调试功能，在特定行上设置断点，可以检查绑定在该点的值
* 设置断点的另一种方法是在程序中包含一个debugger（调试器）语句（仅包含该关键字），如果浏览器的开发人员工具处于活动状态，程序将在达到此语句时暂停

## 8.6 错误传播

## 8.7 异常

* 栈展开：引发一个异常类似于从函数超远距离返回：它不仅跳出当前函数而且跳出其调用者，一直跳到开始当前执行的第一个调用 
* throw关键字用于引发异常
* 捕获异常是通过在try块中包装一段代码，然后在try块加上关键字catch来完成的
* Error构造函数创建异常值，这是一个标准的JavaScript构造函数，用于创建具有message属性的对象。在大多JavaScript环境中，此函数的实例还收集创建异常时存在的调用栈的信息（即所谓的栈追踪）。此信息存储在栈属性中，在尝试调试问题时告诉我们问题发生的位置以及导致失败调用的函数

## 8.8 异常后清理

## 8.9 选择性捕获

## 8.10 断言
